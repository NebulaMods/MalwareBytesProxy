using System.Net;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
using System.Text;

using Newtonsoft.Json;

using Titanium.Web.Proxy;
using Titanium.Web.Proxy.EventArguments;
using Titanium.Web.Proxy.Http;
using Titanium.Web.Proxy.Models;

namespace MalwareBytesProxy;

public class Proxy
{
    public Proxy(string[] args)
    {

    }
    internal async Task RunAsync(string ipAddress, short port)
    {
        var proxyServer = new ProxyServer(machineTrustRootCertificate: true, trustRootCertificateAsAdmin: true)
        {
            TcpTimeWaitSeconds = 10,
            ConnectionTimeOutSeconds = 15,
            ReuseSocket = false,
            EnableConnectionPool = false,
            ForwardToUpstreamGateway = true,
        };
        proxyServer.CertificateManager.SaveFakeCertificates = true;
        proxyServer.CertificateManager.CertificateCacheTimeOutMinutes = 1;
        // locally trust root certificate used by this proxy 
        //proxyServer.CertificateManager.CertificateStorage.Clear();
        var cert = proxyServer.CertificateManager.CertificateStorage.LoadCertificate("MalwareBytes", X509KeyStorageFlags.DefaultKeySet);
        if (cert is null)
        {
            proxyServer.CertificateManager.CreateRootCertificate(true);
            proxyServer.CertificateManager.TrustRootCertificateAsAdmin(true);
            cert = await proxyServer.CertificateManager.CreateServerCertificate("*.mwbsys.com");
            proxyServer.CertificateManager.CertificateStorage.SaveCertificate("MalwareBytes", cert);
        }
        // optionally set the Certificate Engine
        // Under Mono only BouncyCastle will be supported
        proxyServer.BeforeRequest += OnRequest;
        proxyServer.ServerCertificateValidationCallback += OnCertificateValidation;
        proxyServer.ClientCertificateSelectionCallback += OnCertificateSelection;

        var explicitEndPoint = new ExplicitProxyEndPoint(IPAddress.Parse(ipAddress), port, true)
        {
            // Use self-issued generic certificate on all https requests
            // Optimizes performance by not creating a certificate for each https-enabled domain
            // Useful when certificate trust is not required by proxy clients
            GenericCertificate = cert
        };

        // Fired when a CONNECT request is received

        // An explicit endpoint is where the client knows about the existence of a proxy
        // So client sends request in a proxy friendly manner
        proxyServer.AddEndPoint(explicitEndPoint);

        proxyServer.Start();

        foreach (var endPoint in proxyServer.ProxyEndPoints)
            Console.WriteLine("Listening on '{0}' endpoint at Ip {1} and port: {2} ",
                endPoint.GetType().Name, endPoint.IpAddress, endPoint.Port);

        // wait here (You can use something else as a wait function, I am using this as a demo)
        Console.Read();

        // Unsubscribe & Quit
        proxyServer.BeforeRequest -= OnRequest;
        proxyServer.ServerCertificateValidationCallback -= OnCertificateValidation;
        proxyServer.ClientCertificateSelectionCallback -= OnCertificateSelection;
        proxyServer.Stop();

    }

    public async Task OnRequest(object sender, SessionEventArgs e)
    {
        GetState(e).PipelineInfo.AppendLine(nameof(OnRequest) + ":" + e.HttpClient.Request.RequestUri);
        Response response;
        string requestData;
        byte[] data;
        switch (e.HttpClient.Request.RequestUri.AbsolutePath)
        {
            case "//api/v1/installations/check.json":
                Console.WriteLine($"Request from: {e.HttpClient.Request.RequestUri.AbsolutePath} replying with license key.");
                requestData = await e.GetRequestBodyAsString();
                var checkRequest = JsonConvert.DeserializeObject<Models.CheckRequest.Root>(requestData);
                data = Encoding.ASCII.GetBytes(JsonConvert.SerializeObject(new Models.LicenseResponse.Root()
                {
                    status = "ok",
                    installation = new Models.LicenseResponse.Installation
                    {
                        license_key = "Cracked By Nebula",
                        entitlement = new Models.LicenseResponse.Entitlement
                        {
                            term_ends_on = "9999-09-09T23:59:59.000+00:00",
                            term_starts_on = null,
                            renewed_on = null,
                            term_type = "subscription",
                            volume_purchased = 1,
                            volume_status = "legal_usage",
                            term_length = 90,
                            volume_used = 1,
                            status = "active",
                            enabled = true,
                            abused = false,
                            auto_renew = "no",
                            enforce_volume = true,
                            features = "grandfathered=false",
                            products = new List<Models.LicenseResponse.Product>
        {
            new Models.LicenseResponse.Product
            {
                id = 33,
                name = "Malwarebytes Premium",
                customer_type = "consumer",
                active = true,
                code = "MBHS-C",
                two_char_code = "HS",
                grace_multiplier = 1.1,
                grace_term_days = 30,
                is_trial_allowed = false,
                trial_duration = 0,
                trial_max_volume = 1,
                default_key_type = "keystone",
                parent_id = null,
                allow_grace = true,
                enforce_volume = true,
                sellable = true,
                real_product_codes = new List<string>
                {
                    "MBAM-C",
                    "MBMA-C",
                    "MMAC-C"
                },
                featurable_features = new List<object>()
                {

                },
                created_at = "2017-07-17T18:08:24Z",
                updated_at = "2017-07-27T19:11:35Z"
            }
        },
                            key = new Models.LicenseResponse.Key
                            {
                                license_key = "Cracked By Nebula",
                                status = "active",
                                transaction_source = "on_demand",
                                transaction_id = "Lifetime_giveaway_offer_friends_exacttarget_5",
                                source = "keystone",
                                referral_key = "",
                                subscription_id = "",
                                subscription_secret = ""
                            },
                            pids = new List<object>()
                            {

                            },
                            running_number = null
                        },
                        product = new Models.LicenseResponse.Product
                        {
                            id = 1,
                            name = "Malwarebytes 4 Premium",
                            customer_type = "consumer",
                            active = true,
                            code = "MBAM-C",
                            two_char_code = "MC",
                            grace_multiplier = 3,
                            grace_term_days = 30,
                            is_trial_allowed = true,
                            trial_duration = 14,
                            trial_max_volume = 0,
                            default_key_type = "keystone",
                            parent_id = null,
                            allow_grace = true,
                            enforce_volume = true,
                            sellable = true,
                            real_product_codes = null,
                            featurable_features = new List<object>()
                            {
                            },
                            created_at = "2015-02-06T18:32:37Z",
                            updated_at = "2019-07-11T16:24:36Z"
                        },
                        installation_token = checkRequest.installation_token,
                        trial_status = "trial_unavailable",
                        trial_max_volume = 0,
                        trial_starts_on = null,
                        trial_ends_on = null,
                        machine_id = "",
                        product_id = 1,
                        notes = null,
                        product_version = checkRequest.product_version,
                        product_build = checkRequest.product_build,
                        ip_address = "127.0.0.1",
                        volume_used = 1,
                        machine_name = null,
                        friendly_name = null,
                        type = "dynamo",
                        messageable = null,
                        browser_extension_trial_given = null,
                        last_contacted_at = "2020-03-05T06:09:07.560+00:00",
                        registered_at = "2020-02-29T16:37:32.000+00:00",
                        redeemed_at = "2020-03-05T06:09:07.612+00:00"
                    }
                }));
                response = new Response(data)
                {
                    StatusCode = 201,
                    ContentType = "application/json",
                    ContentLength = data.LongLength,
                    HttpVersion = Version.Parse("1.1"),
                };
                e.Respond(response);
                return;
            case "//api/v1/installations/register.json":
                Console.WriteLine($"Request from: {e.HttpClient.Request.RequestUri.AbsolutePath} replying with license key.");
                requestData = await e.GetRequestBodyAsString();
                var registerRequest = JsonConvert.DeserializeObject<Models.RegisterRequest.Root>(requestData);
                data = Encoding.ASCII.GetBytes(JsonConvert.SerializeObject(new Models.LicenseResponse.Root()
                {
                    status = "ok",
                    installation = new Models.LicenseResponse.Installation
                    {
                        license_key = "Cracked By Nebula",
                        entitlement = new Models.LicenseResponse.Entitlement
                        {
                            term_ends_on = "9999-09-09T23:59:59.000+00:00",
                            term_starts_on = null,
                            renewed_on = null,
                            term_type = "subscription",
                            volume_purchased = 1,
                            volume_status = "legal_usage",
                            term_length = 90,
                            volume_used = 1,
                            status = "active",
                            enabled = true,
                            abused = false,
                            auto_renew = "no",
                            enforce_volume = true,
                            features = "grandfathered=false",
                            products = new List<Models.LicenseResponse.Product>
        {
            new Models.LicenseResponse.Product
            {
                id = 33,
                name = "Malwarebytes Premium",
                customer_type = "consumer",
                active = true,
                code = "MBHS-C",
                two_char_code = "HS",
                grace_multiplier = 1.1,
                grace_term_days = 30,
                is_trial_allowed = false,
                trial_duration = 0,
                trial_max_volume = 1,
                default_key_type = "keystone",
                parent_id = null,
                allow_grace = true,
                enforce_volume = true,
                sellable = true,
                real_product_codes = new List<string>
                {
                    "MBAM-C",
                    "MBMA-C",
                    "MMAC-C"
                },
                featurable_features = new List<object>()
                {

                },
                created_at = "2017-07-17T18:08:24Z",
                updated_at = "2017-07-27T19:11:35Z"
            }
        },
                            key = new Models.LicenseResponse.Key
                            {
                                license_key = "",
                                status = "active",
                                transaction_source = "on_demand",
                                transaction_id = "Lifetime_giveaway_offer_friends_exacttarget_5",
                                source = "keystone",
                                referral_key = "",
                                subscription_id = "",
                                subscription_secret = ""
                            },
                            pids = new List<object>()
                            {

                            },
                            running_number = null
                        },
                        product = new Models.LicenseResponse.Product
                        {
                            id = 1,
                            name = "Malwarebytes 4 Premium",
                            customer_type = "consumer",
                            active = true,
                            code = registerRequest.product_code,
                            two_char_code = "MC",
                            grace_multiplier = 3,
                            grace_term_days = 30,
                            is_trial_allowed = true,
                            trial_duration = 14,
                            trial_max_volume = 0,
                            default_key_type = "keystone",
                            parent_id = null,
                            allow_grace = true,
                            enforce_volume = true,
                            sellable = true,
                            real_product_codes = null,
                            featurable_features = new List<object>()
                            {
                            },
                            created_at = "2015-02-06T18:32:37Z",
                            updated_at = "2019-07-11T16:24:36Z"
                        },
                        installation_token = "",
                        trial_status = "trial_unavailable",
                        trial_max_volume = 0,
                        trial_starts_on = null,
                        trial_ends_on = null,
                        machine_id = registerRequest.machine_id,
                        product_id = 1,
                        notes = null,
                        product_version = registerRequest.product_version,
                        product_build = registerRequest.product_build,
                        ip_address = "127.0.0.1",
                        volume_used = 1,
                        machine_name = null,
                        friendly_name = null,
                        type = "dynamo",
                        messageable = null,
                        browser_extension_trial_given = null,
                        last_contacted_at = "2020-03-05T06:09:07.560+00:00",
                        registered_at = "2020-02-29T16:37:32.000+00:00",
                        redeemed_at = "2020-03-05T06:09:07.612+00:00"
                    }
                }));
                response = new Response(data)
                {
                    StatusCode = 201,
                    ContentType = "application/json",
                    ContentLength = data.LongLength,
                    HttpVersion = Version.Parse("1.1"),
                };
                e.Respond(response);
                return;
            case "//api/v1/installations/unredeem.json":
                Console.WriteLine($"Request from: {e.HttpClient.Request.RequestUri.AbsolutePath} replying with plain 200.");
                requestData = await e.GetRequestBodyAsString();
                var deactivateRequest = JsonConvert.DeserializeObject<Models.DeactivateRequest.Root>(requestData);
                response = new Response()
                {
                    StatusCode = 200,
                    HttpVersion = Version.Parse("1.1"),
                };
                e.Respond(response);
                return;
            case "/api/v1/updates/manifest":
                Console.WriteLine($"Request from: {e.HttpClient.Request.RequestUri.AbsolutePath} replying with plain 200.");
                requestData = await e.GetRequestBodyAsString();
                var manifestRequest = JsonConvert.DeserializeObject<Models.ManifestRequest.Root>(requestData);
                response = new Response()
                {
                    StatusCode = 200,
                    HttpVersion = Version.Parse("1.1"),
                };
                e.Respond(response);
                return;
            case "//api/v1/keygen/renew_link":
                Console.WriteLine($"Request from: {e.HttpClient.Request.RequestUri.AbsolutePath} replying with plain 200.");
                response = new Response()
                {
                    StatusCode = 200,
                    HttpVersion = Version.Parse("1.1"),
                };
                e.Respond(response);
                return;
            case "//api/v1/installations/retrieve_key_details":
                Console.WriteLine($"Request from: {e.HttpClient.Request.RequestUri.AbsolutePath} replying with plain 200.");
                response = new Response()
                {
                    StatusCode = 200,
                    HttpVersion = Version.Parse("1.1"),
                };
                e.Respond(response);
                return;
            default:
                Console.WriteLine(e.HttpClient.Request.Url);
                Console.WriteLine(e.HttpClient.Request.RequestUri.AbsolutePath);
                if (e.HttpClient.Request.HasBody)
                {
                    var body = await e.GetRequestBodyAsString();
                    Console.WriteLine(body);
                }
                else
                {
                    Console.WriteLine("request has no body");
                }
                response = new Response()
                {
                    StatusCode = 200,
                    HttpVersion = Version.Parse("1.1"),
                };
                e.Respond(response);
                break;
        }
    }
    // Allows overriding default certificate validation logic
    public Task OnCertificateValidation(object sender, CertificateValidationEventArgs e)
    {
        // set IsValid to true/false based on Certificate Errors
        if (e.SslPolicyErrors == SslPolicyErrors.None)
            e.IsValid = true;

        return Task.CompletedTask;
    }
    public static SampleClientState GetState(ProxyEventArgsBase args)
    {
        if (args.ClientUserData == null) args.ClientUserData = new SampleClientState();

        return (SampleClientState)args.ClientUserData;

    }
    public class SampleClientState
    {
        public StringBuilder PipelineInfo { get; } = new StringBuilder();
    }
    // Allows overriding default client certificate selection logic during mutual authentication
    public Task OnCertificateSelection(object sender, CertificateSelectionEventArgs e)
    {
        // set e.clientCertificate to override
        return Task.CompletedTask;
    }
}
