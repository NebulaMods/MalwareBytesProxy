using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using NebulaMods.Schema;
using NetTools;
using Newtonsoft.Json;
using System.Net.Http;
using System.Reflection;
using System.IO;
using System.Net.Sockets;
using System.Net.Security;
using System.Security.Cryptography.X509Certificates;
using System.Security.Authentication;
using Titanium.Web.Proxy.Models;
using Titanium.Web.Proxy;
using Titanium.Web.Proxy.EventArguments;
using Titanium.Web.Proxy.Http;
using Microsoft.EntityFrameworkCore.Metadata.Internal;

namespace NebulaMods.Services
{
    public class Main
    {
        private readonly Database _database;
        public Main(Database database)
        {
            _database = database;
            //GrabUser("Bearer", "kNV2xoXdtJFRPSdyz4B0kWQ8O9bZd5");
            //var idk = RefreshUserToken(new Member
            //{
            //    id = 0,
            //    userid = 909089360530509825,
            //    access_token = "ifmITDcBLUNcbi4jtFEVTiGjOKTEtD",
            //    refresh_token = "oEL8SGYSUMEa3l97Lj47kYeelKoz3u",
            //    server = 935637941827543090
            //}, "NzkxMTA2MDE4MTc1NjE0OTg4.X-KU5A.FMGrIUyPj89qN8FgdKxlymgA2aI", "791106018175614988", "zQV10oh4g_eFsQ9AfVrxE9BuWmLdCUig").Result;
            //Console.WriteLine(idk);
            //var idk = GetInfo("alkpQ0QMqVVuQYv7rAIcQ4nxWJtlIj").Result;
            //AddUserToGuild();
            //Console.WriteLine($"{idk.access_token}|{idk.refresh_token}");
            //Console.WriteLine(GrabUser("Bearer", idk.access_token));
            //BarryCountChallenge(int.Parse(Console.ReadLine()));\
            //var list = GenerateIPSet(int.Parse(Console.ReadLine()), "BellASN");
            //foreach (var item in list)
            //Console.WriteLine(item);
            //var idk = new List<yeert>();
            //var idk2 = new List<Subnet>();
            //for (int i = 0; i < 255; i++)
            //{
            //    idk.Add(new yeert()
            //    {
            //        address = $"69.171.209.{i}",
            //        dname = "hosted-by.proxywall.net",
            //        ttl = 3600
            //    });
            //}
            //idk2.Add(new Subnet()
            //{
            //    prefix = "69.171.209.0/24",
            //    records = idk
            //});
            //var idk3 = new Root()
            //{
            //    subnets = idk2
            //};
            //File.WriteAllTextAsync("D:/shit.json", JsonConvert.SerializeObject(idk3));
            YessirServer("127.0.0.1", 9999);
            //MalwareBytesServer.Initialize("");
        }
        private async Task YessirServer(string ipAddress, short port)
        {
            var proxyServer = new ProxyServer();
            proxyServer.TcpTimeWaitSeconds = 10;
            proxyServer.ConnectionTimeOutSeconds = 15;
            proxyServer.ReuseSocket = false;
            proxyServer.EnableConnectionPool = false;
            proxyServer.ForwardToUpstreamGateway = true;
            proxyServer.CertificateManager.SaveFakeCertificates = true;
            // locally trust root certificate used by this proxy 
            proxyServer.CertificateManager.CreateRootCertificate();
            proxyServer.CertificateManager.TrustRootCertificateAsAdmin(true);
            var cert = await proxyServer.CertificateManager.CreateServerCertificate("*.mwbsys.com");
            // optionally set the Certificate Engine
            // Under Mono only BouncyCastle will be supported
            //proxyServer.CertificateManager.CertificateEngine = Network.CertificateEngine.BouncyCastle;
            proxyServer.BeforeRequest += OnRequest;
            proxyServer.BeforeResponse += OnResponse;
            proxyServer.ServerCertificateValidationCallback += OnCertificateValidation;
            proxyServer.ClientCertificateSelectionCallback += OnCertificateSelection;

            var explicitEndPoint = new ExplicitProxyEndPoint(IPAddress.Any, 8000, true)
            {
                // Use self-issued generic certificate on all https requests
                // Optimizes performance by not creating a certificate for each https-enabled domain
                // Useful when certificate trust is not required by proxy clients
                GenericCertificate = cert//new X509Certificate2(Path.Combine(@"C:\Users\nebula\Documents\Visual Studio 2022\Projects\Console Test App", "server.pfx"), "password")
            };

            // Fired when a CONNECT request is received

            // An explicit endpoint is where the client knows about the existence of a proxy
            // So client sends request in a proxy friendly manner
            proxyServer.AddEndPoint(explicitEndPoint);

            // Transparent endpoint is useful for reverse proxy (client is not aware of the existence of proxy)
            // A transparent endpoint usually requires a network router port forwarding HTTP(S) packets or DNS
            // to send data to this endPoint
            //var transparentEndPoint = new TransparentProxyEndPoint(IPAddress.Parse(ipAddress), port, true)
            //{
            //    // Generic Certificate hostname to use
            //    // when SNI is disabled by client
            //    //GenericCertificateName = "keystone.mwbsys.com",
            //    GenericCertificate = cert//new X509Certificate2(Path.Combine(@"C:\Users\nebula\Documents\Visual Studio 2022\Projects\Console Test App", "server.pfx"), "password")
            //};

            //proxyServer.AddEndPoint(transparentEndPoint);
            proxyServer.Start();

            //proxyServer.UpStreamHttpProxy = new ExternalProxy() { HostName = "localhost", Port = 8888 };
            //proxyServer.UpStreamHttpsProxy = new ExternalProxy() { HostName = "localhost", Port = 8888 };

            foreach (var endPoint in proxyServer.ProxyEndPoints)
                Console.WriteLine("Listening on '{0}' endpoint at Ip {1} and port: {2} ",
                    endPoint.GetType().Name, endPoint.IpAddress, endPoint.Port);

            // Only explicit proxies can be set as system proxy!
            //proxyServer.SetAsSystemHttpProxy(explicitEndPoint);
            //proxyServer.SetAsSystemHttpsProxy(explicitEndPoint);

            // wait here (You can use something else as a wait function, I am using this as a demo)
            Console.Read();

            // Unsubscribe & Quit
            explicitEndPoint.BeforeTunnelConnectRequest -= OnBeforeTunnelConnectRequest;
            proxyServer.BeforeRequest -= OnRequest;
            proxyServer.BeforeResponse -= OnResponse;
            proxyServer.ServerCertificateValidationCallback -= OnCertificateValidation;
            proxyServer.ClientCertificateSelectionCallback -= OnCertificateSelection;
            proxyServer.Stop();

        }
        public async Task OnRequest(object sender, SessionEventArgs e)
        {
            GetState(e).PipelineInfo.AppendLine(nameof(OnRequest) + ":" + e.HttpClient.Request.RequestUri);

            var clientLocalIp = e.ClientLocalEndPoint.Address;
            if (!clientLocalIp.Equals(IPAddress.Loopback) && !clientLocalIp.Equals(IPAddress.IPv6Loopback))
                e.HttpClient.UpStreamEndPoint = new IPEndPoint(clientLocalIp, 0);

            if (e.HttpClient.Request.Url.Contains("keystone"))
                e.CustomUpStreamProxy = new ExternalProxy("localhost", 8888);

            Console.WriteLine("Active Client Connections:" + ((ProxyServer)sender).ClientConnectionCount);
            Console.WriteLine(e.HttpClient.Request.Url);
            var body = await e.GetRequestBodyAsString();
            Console.WriteLine(body);
            if (e.HttpClient.Request.Url.Contains("check.json"))
            {
                var data = Encoding.ASCII.GetBytes(JsonConvert.SerializeObject(new RedeemLicense1()
                {
                    status = "ok",
                    installation = new Installation
                    {
                        license_key = "",
                        entitlement = new Entitlement
                        {
                            term_ends_on = "9999-09-09T23:59:59.000+00:00",
                            term_starts_on = null,
                            renewed_on = null,
                            term_type = "subscription",
                            volume_purchased = 1,
                            volume_status = "legal_usage",
                            term_length = 90,
                            volume_used = 1,
                            status = "active",
                            enabled = true,
                            abused = false,
                            auto_renew = "no",
                            enforce_volume = true,
                            features = "grandfathered=false",
                            products = new List<Product>
            {
                new Product
                {
                    id = 33,
                    name = "Malwarebytes Premium",
                    customer_type = "consumer",
                    active = true,
                    code = "MBHS-C",
                    two_char_code = "HS",
                    grace_multiplier = 1.1,
                    grace_term_days = 30,
                    is_trial_allowed = false,
                    trial_duration = 0,
                    trial_max_volume = 1,
                    default_key_type = "keystone",
                    parent_id = null,
                    allow_grace = true,
                    enforce_volume = true,
                    sellable = true,
                    real_product_codes = new List<string>
                    {
                        "MBAM-C",
                        "MBMA-C",
                        "MMAC-C"
                    },
                    featurable_features = new List<object>()
                    {

                    },
                    created_at = "2017-07-17T18:08:24Z",
                    updated_at = "2017-07-27T19:11:35Z"
                }
            },
                            key = new Key
                            {
                                license_key = "",
                                status = "active",
                                transaction_source = "on_demand",
                                transaction_id = "Lifetime_giveaway_offer_friends_exacttarget_5",
                                source = "keystone",
                                referral_key = "",
                                subscription_id = "",
                                subscription_secret = ""
                            },
                            pids = new List<object>()
                            {

                            },
                            running_number = null
                        },
                        product = new Product
                        {
                            id = 1,
                            name = "Malwarebytes 3 Premium",
                            customer_type = "consumer",
                            active = true,
                            code = "MBAM-C",
                            two_char_code = "MC",
                            grace_multiplier = 3,
                            grace_term_days = 30,
                            is_trial_allowed = true,
                            trial_duration = 14,
                            trial_max_volume = 0,
                            default_key_type = "keystone",
                            parent_id = null,
                            allow_grace = true,
                            enforce_volume = true,
                            sellable = true,
                            real_product_codes = null,
                            featurable_features = new List<object>()
                            {
                            },
                            created_at = "2015-02-06T18:32:37Z",
                            updated_at = "2019-07-11T16:24:36Z"
                        },
                        installation_token = "",
                        trial_status = "trial_unavailable",
                        trial_max_volume = 0,
                        trial_starts_on = null,
                        trial_ends_on = null,
                        machine_id = "",
                        product_id = 1,
                        notes = null,
                        product_version = "4.1.0",
                        product_build = "consumer",
                        ip_address = "127.0.0.1",
                        volume_used = 1,
                        machine_name = null,
                        friendly_name = null,
                        type = "dynamo",
                        messageable = null,
                        browser_extension_trial_given = null,
                        last_contacted_at = "2020-03-05T06:09:07.560+00:00",
                        registered_at = "2020-02-29T16:37:32.000+00:00",
                        redeemed_at = "2020-03-05T06:09:07.612+00:00"
                    }
                }));
                var response = new Response(data)
                {
                    StatusCode = 201,
                    ContentType = "application/json",
                    ContentLength = data.LongLength,
                };
                e.Respond(response);
            }
            //// read request headers
            //var requestHeaders = e.HttpClient.Request.Headers;
            //if (requestHeaders.FirstOrDefault(x => x.Name == "Host" && x.Value.Contains("api")) is not null)
            //{
            //    e.Ok("<!DOCTYPE html>" +
            //        "<html><body><h1>" +
            //        "Website Blocked" +
            //        "</h1>" +
            //        "<p>Blocked by titanium web proxy.</p>" +
            //        "</body>" +
            //        "</html>");
            //    return;
            //}
            //var method = e.HttpClient.Request.Method.ToUpper();
            //if ((method == "POST" || method == "PUT" || method == "PATCH"))
            //{
            //    // Get/Set request body bytes
            //    byte[] bodyBytes = await e.GetRequestBody();
            //    e.SetRequestBody(bodyBytes);

            //    // Get/Set request body as string
            //    string bodyString = await e.GetRequestBodyAsString();
            //    e.SetRequestBodyString(bodyString);

            //    // store request 
            //    // so that you can find it from response handler 
            //    e.UserData = e.HttpClient.Request;
            //}
            //// To cancel a request with a custom HTML content
            //// Filter URL
            //if (e.HttpClient.Request.RequestUri.AbsoluteUri.Contains("google.com"))
            //{
            //    e.Ok("<!DOCTYPE html>" +
            //        "<html><body><h1>" +
            //        "Website Blocked" +
            //        "</h1>" +
            //        "<p>Blocked by titanium web proxy.</p>" +
            //        "</body>" +
            //        "</html>");
            //}

            //// Redirect example
            //if (e.HttpClient.Request.RequestUri.AbsoluteUri.Contains("wikipedia.org"))
            //{
            //    e.Redirect("https://www.paypal.com");
            //}
        }
        // Allows overriding default certificate validation logic
        public Task OnCertificateValidation(object sender, CertificateValidationEventArgs e)
        {
            // set IsValid to true/false based on Certificate Errors
            if (e.SslPolicyErrors == System.Net.Security.SslPolicyErrors.None)
                e.IsValid = true;

            return Task.CompletedTask;
        }
        private async Task OnBeforeTunnelConnectRequest(object sender, TunnelConnectSessionEventArgs e)
        {
            var hostname = e.HttpClient.Request.RequestUri.Host;
            GetState(e).PipelineInfo.AppendLine(nameof(OnBeforeTunnelConnectRequest) + ":" + hostname);
            Console.WriteLine("Tunnel to: " + hostname);

            var clientLocalIp = e.ClientLocalEndPoint.Address;
            if (!clientLocalIp.Equals(IPAddress.Loopback) && !clientLocalIp.Equals(IPAddress.IPv6Loopback))
                e.HttpClient.UpStreamEndPoint = new IPEndPoint(clientLocalIp, 0);

            if (hostname.Contains("dropbox.com"))
                // Exclude Https addresses you don't want to proxy
                // Useful for clients that use certificate pinning
                // for example dropbox.com
                e.DecryptSsl = false;
        }
        public static SampleClientState GetState(ProxyEventArgsBase args)
        {
            if (args.ClientUserData == null) args.ClientUserData = new SampleClientState();

            return (SampleClientState)args.ClientUserData;

        }
        public class SampleClientState
        {
            public StringBuilder PipelineInfo { get; } = new StringBuilder();
        }
        private async Task<IExternalProxy> OnGetCustomUpStreamProxyFunc(SessionEventArgsBase arg)
        {
            GetState(arg).PipelineInfo.AppendLine(nameof(OnGetCustomUpStreamProxyFunc));

            // this is just to show the functionality, provided values are junk
            return new ExternalProxy
            {
                BypassLocalhost = false,
                HostName = "127.0.0.9",
                Port = 9090,
                Password = "fake",
                UserName = "fake",
                UseDefaultCredentials = false
            };
        }

        private async Task<IExternalProxy> OnCustomUpStreamProxyFailureFunc(SessionEventArgsBase arg)
        {
            GetState(arg).PipelineInfo.AppendLine(nameof(OnCustomUpStreamProxyFailureFunc));

            // this is just to show the functionality, provided values are junk
            return new ExternalProxy
            {
                BypassLocalhost = false,
                HostName = "127.0.0.10",
                Port = 9191,
                Password = "fake2",
                UserName = "fake2",
                UseDefaultCredentials = false
            };
        }
        // Allows overriding default client certificate selection logic during mutual authentication
        public Task OnCertificateSelection(object sender, CertificateSelectionEventArgs e)
        {
            // set e.clientCertificate to override
            return Task.CompletedTask;
        }
        // Modify response
        public async Task OnResponse(object sender, SessionEventArgs e)
        {
            GetState(e).PipelineInfo.AppendLine(nameof(OnResponse));

            if (e.HttpClient.ConnectRequest?.TunnelType == TunnelType.Websocket)
            {
                e.TerminateSession();
            }

            Console.WriteLine("Active Server Connections:" + ((ProxyServer)sender).ServerConnectionCount);

            var ext = Path.GetExtension(e.HttpClient.Request.RequestUri.AbsolutePath);
            //// read response headers
            //var responseHeaders = e.HttpClient.Response.Headers;

            ////if (!e.ProxySession.Request.Host.Equals("medeczane.sgk.gov.tr")) return;
            //if (e.HttpClient.Request.Method == "GET" || e.HttpClient.Request.Method == "POST")
            //{
            //    if (e.HttpClient.Response.StatusCode == 200)
            //    {
            //        if (e.HttpClient.Response.ContentType != null && e.HttpClient.Response.ContentType.Trim().ToLower().Contains("text/html"))
            //        {
            //            byte[] bodyBytes = await e.GetResponseBody();
            //            e.SetResponseBody(bodyBytes);

            //            string body = await e.GetResponseBodyAsString();
            //            e.SetResponseBodyString(body);
            //        }
            //    }
            //}

            //if (e.UserData != null)
            //{
            //    // access request from UserData property where we stored it in RequestHandler
            //    var request = (Request)e.UserData;
            //}
        }
        private Task OnBeforeTunnelConnectResponse(object sender, TunnelConnectSessionEventArgs e)
        {
            GetState(e).PipelineInfo
                .AppendLine(nameof(OnBeforeTunnelConnectResponse) + ":" + e.HttpClient.Request.RequestUri);

            return Task.CompletedTask;
        }
        private async Task MultipartRequestPartSent(object sender, MultipartRequestPartSentEventArgs e)
        {
            GetState(e).PipelineInfo.AppendLine(nameof(MultipartRequestPartSent));

            var session = (SessionEventArgs)sender;
            Console.WriteLine("Multipart form data headers:");
            foreach (var header in e.Headers) Console.WriteLine(header.ToString());
        }
        public static class MalwareBytesServer
        {
            private static X509Certificate cert;
            private static TcpListener server;

            public static void Initialize(string certificate)
            {
                //cert = X509Certificate.CreateFromCertFile(certificate);
                X509Store store = new X509Store(StoreLocation.CurrentUser);
                store.Open(OpenFlags.ReadOnly);
                var cers = store.Certificates.Find(X509FindType.FindBySerialNumber, "1f41ed2f2893a6a0407f3bbd38056a3e", false);
                cert = cers.FirstOrDefault();
                server = new TcpListener(IPAddress.Any, 9999);
                server.Start();
                while (true)
                {
                    Console.WriteLine("Waiting for a client to connect...");

                    TcpClient client = server.AcceptTcpClient();
                    ProcessClient(client);
                }
            }


            private static void ProcessClient(TcpClient client)
            {

                SslStream sslStream = new SslStream(client.GetStream(), false);
                try
                {
                    sslStream.AuthenticateAsServer(cert, false, SslProtocols.None, true);
                    sslStream.ReadTimeout = 5000;
                    sslStream.WriteTimeout = 5000;
                    Console.WriteLine("Waiting for client message...");
                    string messageData = Helpers.ReadMessage(sslStream);
                    byte[] message = Encoding.UTF8.GetBytes("Hello from the server.<EOF>");
                    Console.WriteLine("Sending hello message.");
                    sslStream.Write(message);
                }
                catch (AuthenticationException e)
                {
                    Console.WriteLine("Exception: {0}", e.Message);
                    if (e.InnerException != null)
                    {
                        Console.WriteLine("Inner exception: {0}", e.InnerException.Message);
                    }
                    Console.WriteLine("Authentication failed - closing the connection.");
                    sslStream.Close();
                    client.Close();
                    return;
                }
                finally
                {
                    sslStream.Close();
                    client.Close();
                }
            }



        }
        public static class Helpers
        {
            public static string ReadMessage(SslStream sslStream)
            {
                // Read the  message sent by the server.
                // The end of the message is signaled using the
                // "<EOF>" marker.
                byte[] buffer = new byte[2048];
                StringBuilder messageData = new StringBuilder();
                int bytes = -1;
                do
                {
                    bytes = sslStream.Read(buffer, 0, buffer.Length);
                    Decoder decoder = Encoding.UTF8.GetDecoder();
                    char[] chars = new char[decoder.GetCharCount(buffer, 0, bytes)];
                    decoder.GetChars(buffer, 0, bytes, chars, 0);
                    messageData.Append(chars);
                    // Check for EOF.
                    if (messageData.ToString().IndexOf("<EOF>") != -1)
                    {
                        break;
                    }
                } while (bytes != 0);

                return messageData.ToString();
            }
        }

        private async Task StartMalwareBytesProxy(string ipAddress, short port)
        {
            try
            {
                var proxy = new TcpListener(new IPAddress(IPAddress.Parse(ipAddress).GetAddressBytes()), port);
                proxy.Start();
                //X509Store store = new X509Store(StoreLocation.CurrentUser);
                //store.Open(OpenFlags.ReadOnly);
                //var cers = store.Certificates.Find(X509FindType.FindBySerialNumber, "1f41ed2f2893a6a0407f3bbd38056a3e", false);
                //var cert = cers.FirstOrDefault();
                var cert = new X509Certificate2(@"C:\Users\nebula\Documents\Visual Studio 2022\Projects\Console Test App\server.pfx", "password");
                //var cert = X509Certificate2.CreateFromPemFile(@"C:\Users\nebula\Desktop\nebula-mods-inc\Nebula Mods\certificates\wildcard_bundle_nebulamods.ca.crt", @"C:\Users\nebula\Desktop\nebula-mods-inc\Nebula Mods\certificates\wildcard_nebulamods.ca.key");
                // Buffer for reading data
                while (true)
                {
                    try
                    {
                        Byte[] bytes = new Byte[256];
                        String data = null;
                        using var context = await proxy.AcceptTcpClientAsync();
                        using var stream = context.GetStream();
                        int i;
                        //https connection
                        Byte[] sslBytes = new Byte[256];
                        String sslData = null;
                        int sslI;
                        using var sslStream = new SslStream(stream, false);
                        await sslStream.AuthenticateAsServerAsync(cert, false, System.Security.Authentication.SslProtocols.Tls, false);
                        while ((sslI = await sslStream.ReadAsync(sslBytes)) != 0)
                        {
                            sslData = Encoding.ASCII.GetString(sslBytes, 0, sslI);
                            var sslheaders = data.Split(" ");
                            if (sslheaders.FirstOrDefault("HOST") is not null)
                            {
                                //http connection
                                Console.WriteLine("http connection");
                            }
                            else
                            {
                                sslStream.Close();
                                context.Close();
                            }
                        }
                        //while ((i = await stream.ReadAsync(bytes)) != 0)
                        //{
                        //    data = Encoding.ASCII.GetString(bytes, 0, i);
                        //    var headerlines = data.Split("\r\n");
                        //    var headers = new Dictionary<string, string>();
                        //    foreach (var headerline in headerlines)
                        //    {
                        //        if (string.IsNullOrWhiteSpace(headerline) is false)
                        //        {
                        //            string[] header = headerline.Split(":", 2, StringSplitOptions.None);
                        //            headers.TryAdd(header[0].Trim(), header[1].Trim());
                        //        }
                        //    }
                        //    if (headers.FirstOrDefault(x => x.Value == "keystone.mwbsys.com").Value is not null)
                        //    {
                        //        //https connection
                        //        Byte[] sslBytes = new Byte[256];
                        //        String sslData = null;
                        //        int sslI;
                        //        using var sslStream = new SslStream(stream, false);
                        //        await sslStream.AuthenticateAsServerAsync(cert, false, System.Security.Authentication.SslProtocols.Tls, false);
                        //        while ((sslI = await sslStream.ReadAsync(sslBytes)) != 0)
                        //        {
                        //            sslData = Encoding.ASCII.GetString(sslBytes, 0, sslI);
                        //            var sslheaders = data.Split(" ");
                        //            if (sslheaders.FirstOrDefault("HOST") is not null)
                        //            {
                        //                //http connection
                        //                Console.WriteLine("http connection");
                        //            }
                        //            else
                        //            {
                        //                sslStream.Close();
                        //                context.Close();
                        //            }
                        //        }
                        //    }
                        //    else
                        //    {
                        //        Console.WriteLine("none https connection attempt/request");
                        //    }
                        //}
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex.Message);
                    }
                }
            }
            //"CONNECT keystone.mwbsys.com:443 HTTP/1.1\r\nProxy-Connection: Keep-Alive\r\nHost: keystone.mwbsys.com\r\nProxy-Authorization: Basic Og==\r\n\r\n"
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
    }
}
